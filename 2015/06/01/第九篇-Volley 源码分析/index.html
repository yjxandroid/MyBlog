
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Volley 源码分析 | YJX&#39;S Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="John Doe">
    
    <meta name="description" content="Volley 源码分析图片分析要说源码分析，我们得先看一下官方的配图：
从这张图中我们可以了解到 volley 工作流程：1.请求加入优先队列2.从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到 UI 线程（主线程）。3.从网络中获取数据（如果设置可以缓">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="YJX&#39;S Blog" title="YJX&#39;S Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="YJX&#39;S Blog">YJX&#39;S Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/01/第九篇-Volley 源码分析/" title="Volley 源码分析" itemprop="url">Volley 源码分析</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="John Doe">John Doe</a>
    </p>
  <p class="article-time">
    <time datetime="2015-05-31T16:15:34.000Z" itemprop="datePublished">2015-06-01</time>
    更新日期:<time datetime="2015-05-31T16:15:34.000Z" itemprop="dateModified">2015-06-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Volley_源码分析"><span class="toc-number">1.</span> <span class="toc-text">Volley 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图片分析"><span class="toc-number">1.1.</span> <span class="toc-text">图片分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从这张图中我们可以了解到_volley_工作流程："><span class="toc-number">1.1.0.1.</span> <span class="toc-text">从这张图中我们可以了解到 volley 工作流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-请求加入优先队列"><span class="toc-number">1.1.0.1.0.1.</span> <span class="toc-text">1.请求加入优先队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到_UI_线程（主线程）。"><span class="toc-number">1.1.0.1.0.2.</span> <span class="toc-text">2.从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到 UI 线程（主线程）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到_UI_线程（主线程）。"><span class="toc-number">1.1.0.1.0.3.</span> <span class="toc-text">3.从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到 UI 线程（主线程）。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从图中，我们还可以看到_volley_的工作其实就是三个线程之间的数据传递_主线程_缓存线程_网络线程。"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">从图中，我们还可以看到 volley 的工作其实就是三个线程之间的数据传递 主线程 缓存线程 网络线程。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码分析"><span class="toc-number">1.2.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#至此_volley_框架的整体流程分析完毕！！！！"><span class="toc-number">1.2.0.0.1.</span> <span class="toc-text">至此 volley 框架的整体流程分析完毕！！！！</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#还在说几句：volley_框架的架构设计非常优美！扩展性极高！这个大概得益于_volley_面向接口的设计方案吧！面向接口的架构设计_也是我不断努力的方向！！！！"><span class="toc-number">1.2.0.0.2.</span> <span class="toc-text">还在说几句：volley 框架的架构设计非常优美！扩展性极高！这个大概得益于 volley 面向接口的设计方案吧！面向接口的架构设计 也是我不断努力的方向！！！！</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
		</div>
		
		<h1 id="Volley_源码分析">Volley 源码分析</h1><h2 id="图片分析">图片分析</h2><p><br><br>要说源码分析，我们得先看一下官方的配图：<br><img src="http://ww3.sinaimg.cn/large/a174c633gw1esc7dcevc8j20f60e1q56.jpg" alt="图片"></p>
<h4 id="从这张图中我们可以了解到_volley_工作流程：">从这张图中我们可以了解到 volley 工作流程：</h4><h6 id="1-请求加入优先队列">1.请求加入优先队列</h6><h6 id="2-从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到_UI_线程（主线程）。">2.从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到 UI 线程（主线程）。</h6><h6 id="3-从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到_UI_线程（主线程）。">3.从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到 UI 线程（主线程）。</h6><h4 id="从图中，我们还可以看到_volley_的工作其实就是三个线程之间的数据传递_主线程_缓存线程_网络线程。">从图中，我们还可以看到 volley 的工作其实就是三个线程之间的数据传递 主线程 缓存线程 网络线程。</h4><p><br></p>
<h2 id="代码分析">代码分析</h2><p><br></p>
<p>既然是源码分析，当然是得从源码开始啦（怎么下载源码我就不说了！不会的自行谷歌）！那我们从哪段源码开始嘞？我们就从我们使用 volley 框架的第一句代码开始。</p>
<p>Volley.newRequestQueue(context) 是我们使用 volley 框架的第一句代码！这句代码是用创建个 RequestQueue (请求队列。对，这个就是 volley 工作流程中的第一步的铺垫。这样请求才能有容器装啊！)。那好，我们现在就来看一下 newRequestQueue(context) 这个静态方法：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>{
    <span class="keyword">return</span> newRequestQueue(context, null);
}
<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack <span class="built_in">stack</span>)</span> </span>{
    File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);

    String userAgent = <span class="string">"volley/0"</span>;
    <span class="keyword">try</span> {
        String packageName = context.getPackageName();
        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);
        userAgent = packageName + <span class="string">"/"</span> + info.versionCode;
    } <span class="keyword">catch</span> (NameNotFoundException e) {
    }

    <span class="keyword">if</span> (<span class="built_in">stack</span> == null) {
        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) {
            <span class="built_in">stack</span> = <span class="keyword">new</span> HurlStack();
        } <span class="keyword">else</span> {
            <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span>
            <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span>
            <span class="built_in">stack</span> = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }

    Network network = <span class="keyword">new</span> BasicNetwork(<span class="built_in">stack</span>);

    RequestQueue <span class="built_in">queue</span> = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);
    <span class="built_in">queue</span>.start();

    <span class="keyword">return</span> <span class="built_in">queue</span>;
}
</code></pre><p>从代码中可以看出，我们使用的是 newRequestQueue(Context context, HttpStack stack) 这个函数的重载方法！<br>我简要对这个方法说明下：在系统版本大于等于 9 的时候，我们创建 HurlStack(就是 HttpUrlConnection),在小于 9 的时候我们创建 HttpClientStack(就是 HttpClient) 至于为啥要要这么做。那就是 HttpUrlConnection 的性能要比HttpClient 的好。当然这里我还可以使用另外第三发的 HTTP 库 。比如说 okhttp 。这里我们只要调用 newRequestQueue(Context context, HttpStack stack) 这个方法就行了！当然 要对 okhttp 做简单的封装了！前提是要继承 HttpStack 这个接口啊！</p>
<p>接下来 我们直接看这句代码：RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); 这就是我们要创建的请求队列啦！看 RequestQueue 这个类：</p>
<p>我们先看构造函数（直接看最复杂的！哈哈）</p>
<pre><code><span class="keyword">public</span> RequestQueue(<span class="keyword">Cache</span> <span class="keyword">cache</span>, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache <span class="subst">=</span> <span class="keyword">cache</span>;
    mNetwork <span class="subst">=</span> network;
    mDispatchers <span class="subst">=</span> <span class="literal">new</span> NetworkDispatcher<span class="preprocessor">[</span>threadPoolSize<span class="preprocessor">]</span><span class="markup">;
    mDelivery = delivery;
}</span>
</code></pre><p>可以看到，需要传入 缓存 ，网络执行器，线程池大小，返回结果分发器。这四个参数！接着 我们再来看一下 queue.start() 这句代码的含义！还是一样先看代码：</p>
<pre><code> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{
    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span>
    <span class="comment">// Create the cache dispatcher and start it.</span>
    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = <span class="keyword">new</span>  (mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}
</code></pre><p>先来解释下这这段代码：先停止当前正在运行的所有的线程！接着 初始化 CacheDispatcher(缓存调度器) 并启动他！接着就是启动 NetworkDispatcher(网络调度器) 这有多个。他的个数全靠 threadPoolSize 这个变量控制（默认大小是4）。这样一来。请求队列就是初始化好了！就等待任务加入了啦！！那我们就趁热打铁，直接看加入任务队列的源码：</p>
<pre><code> <span class="keyword">public</span> Request   {
    request.setRequestQueue(<span class="keyword">this</span>);
    <span class="keyword">synchronized</span> (mCurrentRequests) {
        mCurrentRequests.<span class="built_in">add</span>(request);
    }
    request.setSequence(getSequenceNumber());
    request.addMarker(<span class="string">"add-to-queue"</span>);
    <span class="keyword">if</span> (!request.shouldCache()) {
        mNetworkQueue.<span class="built_in">add</span>(request);
        <span class="keyword">return</span> request;
    }
    <span class="keyword">synchronized</span> (mWaitingRequests) {
        <span class="keyword">String</span> cacheKey = request.getCacheKey();
        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) {
            <span class="comment">// There is already a request in flight. Queue up.</span>
            Queue&lt;Request&gt; stagedRequests = mWaitingRequests.<span class="built_in">get</span>(cacheKey);
            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) {
                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();
            }
            stagedRequests.<span class="built_in">add</span>(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            <span class="keyword">if</span> (VolleyLog.DEBUG) {
                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);
            }
        } <span class="keyword">else</span> {
            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);
            mCacheQueue.<span class="built_in">add</span>(request);
        }
        <span class="keyword">return</span> request;
    }
}
</code></pre><p>依旧是来解读这段代码，在解读这该段代码的时候，我们先来弄清楚其中三个变量的含义：</p>
<pre><code><span class="comment">//当前 RequestQueue 中所有的请求队列</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">Set</span>&lt;Request&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&gt;();
<span class="comment">//缓存队列</span>
<span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mCacheQueue =
    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();
<span class="comment">//网络队列 正在进入的</span>
<span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&gt; mNetworkQueue =
    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&gt;();
</code></pre><p>含义如注释！那么我们接着看 add(Request request) 这个方法！首先还是先把任务加入 当前队列。之后request.shouldCache() 判断该任务需要被缓存。不需要的话 直接进入 网络队列！否则的话就加入缓存队列！！</p>
<p>分析完了怎么加入队列之后，我们要来分析下两外两个类了 CacheDispatcher 和 NetworkDispatcher 这里先说下这两个类的共同点：那就是都继承了 Thread 类！也就说他们都是线程类！可以被执行。这也就解释了 RequestQueue 类中的start() 方法中  mCacheDispatcher.start() 和 networkDispatcher.start() 这两句代码！</p>
<p>那么我们先来看一下 CacheDispatcher 这个类！我们直接该类最核心的方法 run() 方法！</p>
<pre><code> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    mCache.initialize();
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
        <span class="keyword">try</span> {
            <span class="comment">// Get a request from the cache triage queue, blocking until</span>
            <span class="comment">// at least one is available.</span>
            <span class="keyword">final</span> Request request = mCacheQueue.take();
            request.addMarker(<span class="string">"cache-queue-take"</span>);

            <span class="comment">// If the request has been canceled, don't bother dispatching it.</span>
            <span class="keyword">if</span> (request.isCanceled()) {
                request.finish(<span class="string">"cache-discard-canceled"</span>);
                <span class="keyword">continue</span>;
            }

            <span class="comment">// Attempt to retrieve this item from cache.</span>
            Cache.Entry entry = mCache.get(request.getCacheKey());
            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) {
                request.addMarker(<span class="string">"cache-miss"</span>);
                <span class="comment">// Cache miss; send off to the network dispatcher.</span>
                mNetworkQueue.put(request);
                <span class="keyword">continue</span>;
            }

            <span class="comment">// If it is completely expired, just send it to the network.</span>
            <span class="keyword">if</span> (entry.isExpired()) {
                request.addMarker(<span class="string">"cache-hit-expired"</span>);
                request.setCacheEntry(entry);
                mNetworkQueue.put(request);
                <span class="keyword">continue</span>;
            }
            <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span>
            request.addMarker(<span class="string">"cache-hit"</span>);
            Response&lt;?&gt; response = request.parseNetworkResponse(
                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));
            request.addMarker(<span class="string">"cache-hit-parsed"</span>);
            <span class="keyword">if</span> (!entry.refreshNeeded()) {
                <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span>
                mDelivery.postResponse(request, response);
            } <span class="keyword">else</span> {
                <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span>
                <span class="comment">// but we need to also send the request to the network for</span>
                <span class="comment">// refreshing.</span>
                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);
                request.setCacheEntry(entry);

                <span class="comment">// Mark the response as intermediate.</span>
                response.intermediate = <span class="keyword">true</span>;

                <span class="comment">// Post the intermediate response back to the user and have</span>
                <span class="comment">// the delivery then forward the request along to the network.</span>
                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() {
                    <span class="annotation">@Override</span>
                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                        <span class="keyword">try</span> {
                            mNetworkQueue.put(request);
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            <span class="comment">// Not much we can do about this.</span>
                        }
                    }
                });
            }

        } <span class="keyword">catch</span> (InterruptedException e) {
            <span class="comment">// We may have been interrupted because it was time to quit.</span>
            <span class="keyword">if</span> (mQuit) {
                <span class="keyword">return</span>;
            }
            <span class="keyword">continue</span>;
        }
    }
}
</code></pre><p>  这段代码中有句代码非常抢眼，没错！那就是 while(true) 这句话了！有的童鞋可能已经想到了：这是个死循环(这不废话！)，另外肯定是在不同的从某个队列中取/存数据。没错，就是这样啊！其实很简单！我们接着细说：首先从缓存队列中去除队列，接着判断该请求是否已经取消 if (request.isCanceled()) 如果已经取消的话，就是不走下面的代码！继续从头循环！反之，从缓存中读取数据，如果没有的话就把该队列加入网络请求队列。如果有的但是缓存已经过期的话 也是加入网络请求队列（  if (entry == null)  和 if (entry.isExpired()) 这两个 if 下的语句就是处理上面两个功能的）。如果以上两个条件都不满足的话！就直接 request.parseNetworkResponse(new NetworkResponse(entry.data, entry.responseHeaders)) 解析缓存中的数据进行回调了！</p>
<p>  下面我们看 NetworkDispatcher 类的代码，同样的我们直接看 核心代码:</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    Request request;
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
        <span class="keyword">try</span> {
            <span class="comment">// Take a request from the queue.</span>
            request = mQueue.take();
        } <span class="keyword">catch</span> (InterruptedException e) {
            <span class="comment">// We may have been interrupted because it was time to quit.</span>
            <span class="keyword">if</span> (mQuit) {
                <span class="keyword">return</span>;
            }
            <span class="keyword">continue</span>;
        }

        <span class="keyword">try</span> {
            request.addMarker(<span class="string">"network-queue-take"</span>);

            <span class="comment">// If the request was cancelled already, do not perform the</span>
            <span class="comment">// network request.</span>
            <span class="keyword">if</span> (request.isCanceled()) {
                request.finish(<span class="string">"network-discard-cancelled"</span>);
                <span class="keyword">continue</span>;
            }

            <span class="comment">// Tag the request (if API &gt;= 14)</span>
            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());
            }

            <span class="comment">// Perform the network request.</span>
            NetworkResponse networkResponse = mNetwork.performRequest(request);
            request.addMarker(<span class="string">"network-http-complete"</span>);

            <span class="comment">// If the server returned 304 AND we delivered a response already,</span>
            <span class="comment">// we're done -- don't deliver a second identical response.</span>
            <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) {
                request.finish(<span class="string">"not-modified"</span>);
                <span class="keyword">continue</span>;
            }

            <span class="comment">// Parse the response here on the worker thread.</span>
            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
            request.addMarker(<span class="string">"network-parse-complete"</span>);

            <span class="comment">// Write to cache if applicable.</span>
            <span class="comment">// TODO: Only update cache metadata instead of entire record for 304s.</span>
            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) {
                mCache.put(request.getCacheKey(), response.cacheEntry);
                request.addMarker(<span class="string">"network-cache-written"</span>);
            }

            <span class="comment">// Post the response back.</span>
            request.markDelivered();
            mDelivery.postResponse(request, response);
        } <span class="keyword">catch</span> (VolleyError volleyError) {
            parseAndDeliverNetworkError(request, volleyError);
        } <span class="keyword">catch</span> (Exception e) {
            VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());
            mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));
        }
    }
}
</code></pre><p>同样的是，先从网络请求队列中取出任务，接着在判断是否要取消，如果要则跳过下面的代码，重新取任务！调用   NetworkResponse networkResponse = mNetwork.performRequest(request); 这句代码，获取 网络返回结果！接着，代码和 CacheDispatcher 中差不多！唯一的区别就是：如果当前的请求需要加入缓存，则加入缓存！细心的同学可能发现了，CacheDispatcher 和 NetworkDispatcher 这两个类中有句相同的代码   Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); 就是这句！核心的就是parseNetworkResponse(networkResponse) 这个函数的实现我在上一篇 <a href="http://www.cnblogs.com/likeandroid/" target="_blank" rel="external">Volley 的使用以及自定义Request</a> 中已经说过了！是有我们实现的！</p>
<p>这里的我们还得在注意一个类：那就是 BasicNetwork ！其实这个类没有什么可以细说的！他就是请求网络接着返回结果！我这里也把核心代码上一下：</p>
<pre><code>  <span class="keyword">public</span> NetworkResponse performRequest(Request&lt;?&gt; request) <span class="keyword">throws</span> VolleyError {
    <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();
    <span class="keyword">while</span> (<span class="keyword">true</span>) {
        HttpResponse httpResponse = <span class="keyword">null</span>;
        <span class="built_in">byte</span>[] responseContents = <span class="keyword">null</span>;
        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; responseHeaders = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();
        <span class="keyword">try</span> {
            <span class="comment">// Gather headers.</span>
            Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; headers = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();
            addCacheHeaders(headers, request.getCacheEntry());
            httpResponse = mHttpStack.performRequest(request, headers);
            StatusLine statusLine = httpResponse.getStatusLine();
            <span class="built_in">int</span> statusCode = statusLine.getStatusCode();

            responseHeaders = convertHeaders(httpResponse.getAllHeaders());
            <span class="comment">// Handle cache validation.</span>
            <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) {
                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,
                        request.getCacheEntry().data, responseHeaders, <span class="keyword">true</span>);
            }

            responseContents = entityToBytes(httpResponse.getEntity());
            <span class="comment">// if the request is slow, log it.</span>
            <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;
            logSlowRequests(requestLifetime, request, responseContents, statusLine);

            <span class="keyword">if</span> (statusCode != HttpStatus.SC_OK &amp;&amp; statusCode != HttpStatus.SC_NO_CONTENT) {
                <span class="keyword">throw</span> <span class="keyword">new</span> IOException();
            }
            <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);
        } <span class="keyword">catch</span> (SocketTimeoutException e) {
            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());
        } <span class="keyword">catch</span> (ConnectTimeoutException e) {
            attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());
        } <span class="keyword">catch</span> (MalformedURLException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);
        } <span class="keyword">catch</span> (IOException e) {
            <span class="built_in">int</span> statusCode = <span class="number">0</span>;
            NetworkResponse networkResponse = <span class="keyword">null</span>;
            <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) {
                statusCode = httpResponse.getStatusLine().getStatusCode();
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);
            }
            VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());
            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) {
                networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,
                        responseHeaders, <span class="keyword">false</span>);
                <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||
                        statusCode == HttpStatus.SC_FORBIDDEN) {
                    attemptRetryOnException(<span class="string">"auth"</span>,
                            request, <span class="keyword">new</span> AuthFailureError(networkResponse));
                } <span class="keyword">else</span> {
                    <span class="comment">// TODO: Only throw ServerError for 5xx status codes.</span>
                    <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);
                }
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);
            }
        }
    }
}
</code></pre><p>这个类 我就真的不细讲啦！！</p>
<p>上面已经说了，在解析玩数据之后其实就分发数据了！让用户能够在 UI线程中调用了！现在我们就来看一下这个分发类：ExecutorDelivery。 我们还是先看这个类的构造函数：</p>
<pre><code> <span class="keyword">public</span>  (<span class="keyword">final</span> Handler <span class="keyword">handler</span>) {
    <span class="comment">// Make an Executor that just wraps the handler.</span>
    mResponsePoster = <span class="keyword">new</span> Executor() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{
            <span class="keyword">handler</span>.post(command);
        }
    };
}
</code></pre><p>从代码中我们可以看到，我们需要传一个Handller进入，此时我们在回想一下这个类在 RequestQueue 类中是怎么初始化的？</p>
<pre><code> <span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>{
    <span class="keyword">this</span>(cache, network, threadPoolSize,
            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));
}
</code></pre><p>没错！大家可以看到，是传入了一个主线中的handler！</p>
<p>当在 CacheDispatcher 和 NetworkDispatcher 这两个类中调用了   mDelivery.postResponse(request, response); 这个方法的时，我们来看一下 ExecutorDelivery 这个类都做了什么！</p>
<pre><code><span class="keyword">public</span> void postResponse(<span class="built_in">Request</span>&lt;?&gt; <span class="built_in">request</span>, <span class="built_in">Response</span>&lt;?&gt; <span class="built_in">response</span>, Runnable runnable) {
    <span class="built_in">request</span>.markDelivered();
    <span class="built_in">request</span>.addMarker(<span class="string">"post-response"</span>);
    mResponsePoster.<span class="keyword">execute</span>(<span class="keyword">new</span> ResponseDeliveryRunnable(<span class="built_in">request</span>, <span class="built_in">response</span>, runnable));
}
</code></pre><p>我们直接执行了了个Runnable—&gt;ResponseDeliveryRunnable。那他又做了什么呢？</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
       <span class="comment">// If this request has canceled, finish it and don't deliver.</span>
       <span class="keyword">if</span> (mRequest.isCanceled()) {
           mRequest.finish(<span class="string">"canceled-at-delivery"</span>);
           <span class="keyword">return</span>;
       }

       <span class="comment">// Deliver a normal response or error, depending.</span>
       <span class="keyword">if</span> (mResponse.isSuccess()) {
           mRequest.deliverResponse(mResponse.result);
       } <span class="keyword">else</span> {
           mRequest.deliverError(mResponse.<span class="keyword">error</span>);
       }

       <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span>
       <span class="comment">// and the request can be finished.</span>
       <span class="keyword">if</span> (mResponse.intermediate) {
           mRequest.addMarker(<span class="string">"intermediate-response"</span>);
       } <span class="keyword">else</span> {
           mRequest.finish(<span class="string">"done"</span>);
       }

       <span class="comment">// If we have been provided a post-delivery runnable, run it.</span>
       <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) {
           mRunnable.run();
       }
  }
</code></pre><p> 我们看最直接的这句代码   mRequest.deliverResponse(mResponse.result); 我们调用了 Request的中的一个方法（这个方法，依然是要我们自己实现！）。接着，我们在看 ExecutorDelivery 的构造函数时，我们就会豁然开朗！数据终于到了 UI线程了！</p>
<h5 id="至此_volley_框架的整体流程分析完毕！！！！">至此 volley 框架的整体流程分析完毕！！！！</h5><h5 id="还在说几句：volley_框架的架构设计非常优美！扩展性极高！这个大概得益于_volley_面向接口的设计方案吧！面向接口的架构设计_也是我不断努力的方向！！！！">还在说几句：volley 框架的架构设计非常优美！扩展性极高！这个大概得益于 volley 面向接口的设计方案吧！面向接口的架构设计 也是我不断努力的方向！！！！</h5>  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/volley-源码/">volley 源码</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Volley-源码分析/">Volley 源码分析</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/06/01/第九篇-Volley 源码分析/" data-title="Volley 源码分析 | YJX&#39;S Blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/01/第二篇-android APP是否需要缓存？+简单架构/" title="APP 是否需要缓存">
  <strong>PREVIOUS:</strong><br/>
  <span>
  APP 是否需要缓存</span>
</a>
</div>


<div class="next">
<a href="/2015/06/01/第三篇-android ViewPager页面切换特效/"  title="ViewPager页面切换特效如下效果">
 <strong>NEXT:</strong><br/> 
 <span>ViewPager页面切换特效如下效果
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Volley_源码分析"><span class="toc-number">1.</span> <span class="toc-text">Volley 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图片分析"><span class="toc-number">1.1.</span> <span class="toc-text">图片分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从这张图中我们可以了解到_volley_工作流程："><span class="toc-number">1.1.0.1.</span> <span class="toc-text">从这张图中我们可以了解到 volley 工作流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-请求加入优先队列"><span class="toc-number">1.1.0.1.0.1.</span> <span class="toc-text">1.请求加入优先队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到_UI_线程（主线程）。"><span class="toc-number">1.1.0.1.0.2.</span> <span class="toc-text">2.从缓存调度器中查看是否存在该请求，如果有（没有进入第三步）直接缓存中读取并解析数据，最后分发到 UI 线程（主线程）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到_UI_线程（主线程）。"><span class="toc-number">1.1.0.1.0.3.</span> <span class="toc-text">3.从网络中获取数据（如果设置可以缓存，则写入缓存）并解析数据，最后分发到 UI 线程（主线程）。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从图中，我们还可以看到_volley_的工作其实就是三个线程之间的数据传递_主线程_缓存线程_网络线程。"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">从图中，我们还可以看到 volley 的工作其实就是三个线程之间的数据传递 主线程 缓存线程 网络线程。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码分析"><span class="toc-number">1.2.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#至此_volley_框架的整体流程分析完毕！！！！"><span class="toc-number">1.2.0.0.1.</span> <span class="toc-text">至此 volley 框架的整体流程分析完毕！！！！</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#还在说几句：volley_框架的架构设计非常优美！扩展性极高！这个大概得益于_volley_面向接口的设计方案吧！面向接口的架构设计_也是我不断努力的方向！！！！"><span class="toc-number">1.2.0.0.2.</span> <span class="toc-text">还在说几句：volley 框架的架构设计非常优美！扩展性极高！这个大概得益于 volley 面向接口的设计方案吧！面向接口的架构设计 也是我不断努力的方向！！！！</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
			<li><a href="/categories/Android应用开发/" title="Android应用开发">Android应用开发<sup>9</sup></a></li>
		
			<li><a href="/categories/Volley-源码分析/" title="Volley 源码分析">Volley 源码分析<sup>1</sup></a></li>
		
			<li><a href="/categories/思考/" title="思考">思考<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			<li><a href="/tags/ListView/" title="ListView">ListView<sup>1</sup></a></li>
		
			<li><a href="/tags/ViewPager/" title="ViewPager">ViewPager<sup>1</sup></a></li>
		
			<li><a href="/tags/volley-源码/" title="volley 源码">volley 源码<sup>1</sup></a></li>
		
			<li><a href="/tags/主题切换/" title="主题切换">主题切换<sup>1</sup></a></li>
		
			<li><a href="/tags/缓存/" title="缓存">缓存<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="John Doe">John Doe</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
